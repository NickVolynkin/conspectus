# Как создать 10 приложений из одного и не сойти с ума

*Анна Мошкина, IPONWEB*

* IPONWEB - системы автоматизации показа рекламы. Обрабатывает запросы в рекламную систему. 
* Делаем UI для таких систем, для администраторов. Клиенты - рекламодатели и паблишеры, владельцы сайтов, экранов, приложений, агентства. 
* Клиентские проекты
* No highload

## Как мы штампуем админки
 
 * Начинали с одного простого проекта на django
 * Появилось требование, что таких проектов разных, но похожих друг на друга, будет много. Следующие копипастим... 
 * Но обнаружились проблемы, приходилось менять код в неск местах, копипастились ошибки. 
 * Общую часть решили вынести в библиотеку, проект подключает компоненты из нее. Сменили несколько подходов к организации этой либы.  
* Сейчас мы описываем подключением компонентов либы с помощью JSOn based DSL, который мы называем конфигурацией. 
* Фронт на ангуляре, сборка с помощью webpack, логика читается из json-конфига, размером 1000 строк. Часть генерится автоматически, часть - руками. UI на его основе отрисовывает форму и ее содержимое. Для клиентов они разные. Бэкэнл процессит конфиг, прежде чем отдать в UI.
* No rocket science, аналитики или вычислений. Он предоставляет CRUD, создать XML с настройками рекламной системой. Django+DRF.  Считывает json один раз на старте приложения.  
* Если пользователю не должны быть доступны части системы - отдает 403. 

## Термины

* Entity, сущность - форма.
* Feature - отдельные поля, части. 
* Endpoint - URL. 

В конфигурации есть секции для всех этих компонентов. 

## Гибкая структура БД

* PostgreSQL
* Гибкая структура на основе many2many связей. Креатив храним отдельно от свойств, сущность отдельно от фичей. LinkRegistry - хранит ссылку на запись в обеих таблицах, записи представляют единое целое - весь объект. 
* Ходить в каждую таблицу отдельно неудобно. Мы используем динамические модели и сериалайзеры. В модели есть только айдишник. С помощью динамического создания типа и сохраняем в глобал реджистри, откуда и используем. 
* Как они отвечают за сбор уже сохранненных данных, собранных из моделей: сериалайзеры обычные DRF, валидируют данные, а также раскладывают по таблицам. Могут смотреть в модель и понимать, где оно хранится по типу полей в модели. Самописные филды, которые отвечают за связь с другиим таблицами. 
Если поле относится к другой таблице, то сериалайзер это понимает, данные друг с другом связываются внутри модели. В спец филдах мы переопределяем механизм дескрипторов. Под капотом делаем линковку через таблицу между значениями, которые пользователь передал.
* fromDB() метод в модели, которому в параметре приходит tuple, он его конвертит в dict, инициализирует модель, получает ее инстантс и возвращает его. Используем переопределенный метод fromDB(), мы получаем в tuple только id,а мы хотим все атрибуты. Поэтому берем в нем доп данные из других таблиц, инициализируем и отдаем. 
* Так происходит везде, где вы работаете с querysets. В приложении получаете нормальные сформированные объекты со всеми полями внутри модели.
* У нас оптимизирован prefetch django под наш юз кейс. 
* Почему Django+PS - удобно для команды. 

## Тестирование

* Много тестируем, так как фреймворк сложный. 
* тестраннер - pytest. 
* Тесты для ядра и в проектах
* В ядре есть юниты, плагин pytest-django, тестируем эндпойнты прямо в либе. 
* Функциональные тесты на апи, можно давать json конфигурацию. Для каждого теста можно указать свою. 
* dummy names для сущностей (Emma, Anna, etc), с которыми тестируем код в ядре, так как не хотим замыкаться на бизнес-контекст. 
* Всю работу с базой тестируем через апи
* Тесты в проектах. Тесты на ядро и тесты, которые подключаются в проектах (project-compat). Они смотрят в конфиг, понимают, какие сущности используют фичу и прогоняют тесты для найденных. 
* В проектах не используем dummy names или тестовую конфигурацию, только настоящую. 
* E2E тесты, run by protractor, json. 
* Хелперы для генерации тестовых данных, учитывают конфиг и собирают валидные тестовые данные в зависимости от него. 


