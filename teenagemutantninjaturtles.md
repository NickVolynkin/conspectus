# Мутационное тестирование

<p align="right">
<a href = "https://conf.python.ru/2019"><img src = "https://raw.githubusercontent.com/docops-hq/conf/master/moscowpython/19/static/i_pc.png" width="20px" height=20px"> Moscow Python Conf++</a> 
</p>

*Никита Соболев, wemakeservices*

## Проблема-решения

* Больше тестов = затык на CI
* Лучше писать те, что проверяют
* Повысим покрытие! 
* Тестируете ли вы тесты?
* Давайте строже ревьюить! Но ревьюить тесты долго, 1 строка - 10 тестов. 
* повышаем читаемость тестов
* Автоматизируем!
* тесты на тесты!

## Растим мутантов

* Отладка - меняем код в случайных местах. Тоже не оптимально, поскольку не понятно, вы сломали или починили. 
* Лучше сломаем все, пока не заработает. 
* Вносим в код, в логику небольшие отклонения, чтобы проверять, как тесты с этим справятся. Эти маленькие ошибки - мутанты.  
* Таким образом меняем каждую строчку в проекте - тесты должны начать падать. 

## Варианты развития

* падение тестов
* все в порядке - система пропустила ошибки
* таймаут. 

## Как делать

* Берем абстрактное синтаксическое дерево, парсим код и понимаем, что происходит
* Заменяем на похожие фрагменты кода
* Например, меняем -/+, true/false, >/>=.

## Инструменты

[Pic1](https://ibb.co/hBchWXr)

* CosmicRay
* MutePy
* MuteMute

## Какие ошибки можно найти

* Ошибки в данных, плохие данные. *Дополняйте данные!*

[Pic2](https://ibb.co/89FDzd8)
[Pic3](https://ibb.co/HYzCn9z)

* Частичные тесты - тестируем только часть логики. *тестируйте все! тестируйте сайд эффекты*
* Находим медленные тесты, например, celery уходит в бесконечный луп. Поставьте таймаут. 
* и много других ошибок!

## Лишние мутанты

* Не все строки нужно мутировать, например, номер версии. Можно игнорировать. Можно запускать выборочно .patch. 
* Найти точные куски кода для запуска, собираем coverage, запускаем мутации кода, попавшего в coverage. `--path-to-mutate`

## Скорость

* Долго, много кода, все надо поменять и запустить тесты
* 1 секунда - 1000 мутаций, 16 минут. 
* Уменьшаем! Отключаем плагины, доп проверки, выиграли минуту. Отключаем выводы `--quiet`. Падаем на первом упавшем `--exitfirst`. Запускаем один раз coverage - запускаем мутационные. Запустить только кусок, относящийся к текущим изменениям `--testmon`. = *4 минуты!*

## Нужно меньше, но лучше

* postmutation hook - запись упавших тестов в базу, проверять, какие тесты никогда не падают - от них нужно избавиться. 
* Связка с TDD - кусок кода, тесты, мутации кода, мутации тестов. Оптимальный подход. Получаем понимание, какие тесты выполняются, какие нужно мутировать. Вы изначально пишете хорошие тесты. 
* Property-based tests - плохие данные, если тесты работают даже с изменением кодом, в этих местах можно применять property-based tests. 
* E2E - *НЕТ*, ни в коем случае. 

## Когда не нужно

* Есть линтеры, typechecking, тестирование документации - тогда пора. 

## Вопросы

* Сколько будут идти мутационные тесты в автоматизированной системе? Проблема в том, что мутировать нужно избранные куски, собирать. Разрешить джобе падать, так как она будет падать все время, и генерировать отчет, который нужно смотреть глазами. + использовать утилиту для дедупликейта тестов. Она работает порядка 6 часов. 
* Что происходит на процессу бутстрапа? runner какое-то время коллектит тесты, затем парсит тесты, находит стратегии, запускает процессы - тесты, проверка результата и т.д. 
* Кейсы? Например, TDD 

